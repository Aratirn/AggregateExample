# Aggregate Example 2

## Definitions for this demonstration
* **Aggregate**: A logical set of entities that are typical viewed as a single operational unit by the business.
* **Entity**: A business object that possesses an identity. This usually means the object has a business-related life cycle.
* **Aggregate Root**: An entity that is a transactional boundary for the aggregate. Whether the aggregate contains 1 entity or or 100, all operations against the aggregate must go through the aggregate root. This is also the object that is persisted whether it be through a relational database or event stream.
* **Subordinate Entity**: Simply a term I am currently using to describe an entity within an aggregate that is not the aggregate root.

## Design Motivation / Problems Solved
* Repositories should only deal in Aggregate Roots. To enforce this, separate supporting base classes into Entity and AggregateRoot (which inherits from Entity), and then the repository only accepts and returns instances of AggregateRoot
* Clients of the domain should only hold references to Aggregate Roots and not attempt to (or be able to) manipulate subordinate entities directly.
* The Aggregate Root will need some infrastructure to allow the Repository to persist any uncommitted events and to allow the Repository to replay the events when the AR is recalled. This is specific to event sourcing which is what being illustrated in this demo.
* The Aggregate Root will "own" all of the events generated by its subordinate entities. This means that all events of the AR and its subordinate entities will be saved on the AR's stream.
* The purpose of events in event sourcing is to contain enough information about the action that was taken in order to recreate the state of the object at the point in time in which the event took place. Since all actions against the aggregate must happen through the aggregate root, it stands to reason that the root should "own" all of the events. I am taking this to mean that the aggregate root is the only object that has its own stream in the event store.

## Entity Traits
* Business Entities inherit from `Entity` (e.g. ` BusinessLedger : Entity`)
* Entities have identity. They are unique within the aggregate.
* Entities encapsulate business rules relevant to its business representation. 
* Methods within the Entity return events when successful and throw when unsuccessful.
* Entities will separate operations into the semantically-named method and an internal Apply() method.
  * The semantically named method's responsibility is validation. When successful, it will return an appropriate event.
  * The Apply() method will bypass validation and update the state of the entity.
* To help facilitate the guideline that clients should only hold references to AggregateRoots and not subordinate entities, Entities are declared as internal. 

## Aggregate Root (AR) Traits
* The AR base class inherits from Entity. Aggregate Root implementations inherit from `AggregateRoot` (e.g. `Customer : AggregateRoot`)
* The AR will separate operations into the semantically-named method and an internal Apply() method, similar to Entity
* When the AR interacts with subordinate Entity methods successfully, it will receive resultant Events and "Raise" them. Doing so will both add them to uncommitted changes and also call the respective Apply() method on the AR
* When the AR interacts is unable to complete a command because either it or the subordinate entity refused it, it will rethrow or allow any other exceptions to bubble up.
  * <span style="color:red">I am considering removing the exception (see: Exceptions should be exceptional) in lieu of an error event. This would provide much better tracking/auditing and potentionally save on some resources. I'm putting this off until I come up with or find a clean pattern to support this behavior.</span>
* Apply methods will either update the state of the AR, or the respective subordinate entity. 
  * This means, there will be apply methods contained on the AR for all AR events as well as all subordinate Entity events
  * When the event is supposed to update the AR, it will do so. When the event is supposed to update a subordinate Entity, it must forward the event to the respective entity's ApplyMethod. 
  * If the subordinate entity does not yet exist, then the AR must create it and then apply the event to it. In order for this to work, the Apply methods should be accessible (public or internal) and the entities must have an accessible default constructor.

